name: ECS Service Deployment

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: Read config.json and set environment variables
        id: read_config
        run: |
          region=$(jq -r '.aws.region' config.json)
          ecrRepositoryName=$(jq -r '.aws.ecrRepositoryName' config.json)
          ecsClusterName=$(jq -r '.aws.ecsClusterName' config.json)
          ecsServiceName=$(jq -r '.aws.ecsServiceName' config.json)
          elbName=$(jq -r '.aws.elbName' config.json)
          ecsTaskExecutionRole=$(jq -r '.aws.ecsTaskExecutionRole' config.json)
          taskdef=$(jq -r '.aws.taskdef' config.json)

          echo "REGION=$region" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_NAME=$ecrRepositoryName" >> $GITHUB_ENV
          echo "ECS_CLUSTER_NAME=$ecsClusterName" >> $GITHUB_ENV
          echo "ECS_SERVICE_NAME=$ecsServiceName" >> $GITHUB_ENV
          echo "ELB_NAME=$elbName" >> $GITHUB_ENV
          echo "ECS_TASK_ROLE=$ecsTaskExecutionRole" >>$GITHUB_ENV
          echo "TASK_NAME=$taskdef" >>$GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ env.REGION }} 

      
      - name: Clear Docker layers and clear yarn cache
        run: |
          docker system prune -af --volumes
          yarn cache clean
      
      - name: Build and push App Docker image
        run: |
            echo "CARGO_NET_GIT_FETCH_WITH_CLI=true" >> $GITHUB_ENV
            docker-compose up --build -d 

      - name: Check if ECS cluster exists
        id: check_cluster
        run: |
          aws ecs describe-clusters --cluster ${{ env.ECS_CLUSTER_NAME}} || exit 0

      - name: Check if ECS repository exists
        id: check_repository
        run: |
            if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_NAME }}; then
              echo "Repository already exists"
            else
              echo "Repository does not exist"
              echo "::set-output name=REPO_EXISTS::false"
            fi
        
      - name: Check if ECS task definition exists
        id: check_task_definition
        run: |
            aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_NAME}} || exit 0

      - name: Create ECS cluster if not exists
        if: steps.check_cluster.outputs.stdout == ''
        run: |
          aws ecs create-cluster --cluster-name ${{ env.ECS_CLUSTER_NAME }}

      - name: Create ECR if not exists
        if: steps.check_repository.outputs.REPO_EXISTS == 'false'
        run: |
            aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_NAME }}
      
      - name: Push the repository
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG1: app
                
        run: |
            docker tag $IMAGE_TAG1  ${{secrets.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.REGION}}.amazonaws.com/$ECR_REPOSITORY_NAME:$IMAGE_TAG1
            docker push  ${{secrets.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.REGION}}.amazonaws.com/$ECR_REPOSITORY_NAME:$IMAGE_TAG1

      - name: Retrieve AWS account ID
        id: get-account-id
        run: echo "AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)" >> $GITHUB_ENV
          
      - name: Create task definiton
        id: create_task
        run: | 
                aws ecs register-task-definition \
                --family ${{env.TASK_NAME}} \
                --execution-role-arn "arn:aws:iam::${{secrets.AWS_ACCOUNT_ID}}:role/${{env.ECS_TASK_ROLE}}" \
                --container-definitions '[
                    {
                      "name": "App",
                     "image": ${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.REGION}}.amazonaws.com/$ECR_REPOSITORY_NAME:$IMAGE_TAG1,
                      "memoryReservation": 512,
                      "cpu": 256,
                      "essential": true,
                      "portMappings": [
                          {
                            "containerPort": 80,
                            "hostPort": 3000
                          }
                                    ]
                    }
                            ]' \
                --requires-compatibilities FARGATE


      - name: Update and Run ECS Service
        run: |
            if aws ecs describe-services --cluster ${{ env.ECS_CLUSTER_NAME}} --service ${{env.ECS_SERVICE_NAME}} &> /dev/null; then
            aws ecs update-service --cluster ${{ env.ECS_CLUSTER_NAME}} --service ${{env.ECS_SERVICE_NAME}} --force-new-deployment
            else
            aws ecs create-service --cluster ${{ env.ECS_CLUSTER_NAME}}  --service-name ${{env.ECS_SERVICE_NAME}} --task-definition ${{ env.TASK_NAME}}
            fi
          # aws ecs update-service --cluster $ECS_CLUSTER --service $SERVICE_NAME --task-definition $TASK_DEF_ARN --force-new-deployment

      
      
